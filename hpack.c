#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <limits.h>
#include <math.h>
#include "hpack.h"

#define hpack_likely(x) __builtin_expect(!!(x), 1)
#define hpack_unlikely(x) __builtin_expect(!!(x), 0)

#define byte uint8_t
#define SPLIT_1 '\t'
#define SPLIT_2 '\n'

#if 1
#define HANDLE_ERROR(x)                                                               \
    do {                                                                              \
        int err = (x);                                                                \
        if (hpack_unlikely(err)) {                                                    \
            fprintf(stderr, "%s:%d, Error(%d) at %s\n", __FILE__, __LINE__, err, #x); \
            return err;                                                               \
        }                                                                             \
    } while (0)
#else
#define HANDLE_ERROR(x)     \
    do {                    \
        if ((x)) return -1; \
    } while (0)
#endif

typedef struct hpack_index {
    long id;           /* Index */
    const char *name;  /* Header Name */
    const char *value; /* Value */
    const int name_len;
} hpack_index_t;

#define HPACK_STATIC_SIZE (sizeof(static_table) / sizeof(static_table[0]))
static hpack_index_t static_table[] = {
    /* make the formatter happy*/
    {1, ":authority", NULL, 10},
    {2, ":method", "GET", 7},
    {3, ":method", "POST", 7},
    {4, ":path", "/", 5},
    {5, ":path", "/index.html", 5},
    {6, ":scheme", "http", 7},
    {7, ":scheme", "https", 7},
    {8, ":status", "200", 7},
    {9, ":status", "204", 7},
    {10, ":status", "206", 7},
    {11, ":status", "304", 7},
    {12, ":status", "400", 7},
    {13, ":status", "404", 7},
    {14, ":status", "500", 7},
    {15, "accept-charset", NULL, 14},
    {16, "accept-encoding", "gzip, deflate", 15},
    {17, "accept-language", NULL, 15},
    {18, "accept-ranges", NULL, 13},
    {19, "accept", NULL, 6},
    {20, "access-control-allow-origin", NULL, 27},
    {21, "age", NULL, 3},
    {22, "allow", NULL, 5},
    {23, "authorization", NULL, 13},
    {24, "cache-control", NULL, 13},
    {25, "content-disposition", NULL, 19},
    {26, "content-encoding", NULL, 16},
    {27, "content-language", NULL, 16},
    {28, "content-length", NULL, 14},
    {29, "content-location", NULL, 16},
    {30, "content-range", NULL, 13},
    {31, "content-type", NULL, 12},
    {32, "cookie", NULL, 6},
    {33, "date", NULL, 4},
    {34, "etag", NULL, 4},
    {35, "expect", NULL, 6},
    {36, "expires", NULL, 7},
    {37, "from", NULL, 4},
    {38, "host", NULL, 4},
    {39, "if-match", NULL, 8},
    {40, "if-modified-since", NULL, 17},
    {41, "if-none-match", NULL, 13},
    {42, "if-range", NULL, 8},
    {43, "if-unmodified-since", NULL, 19},
    {44, "last-modified", NULL, 13},
    {45, "link", NULL, 4},
    {46, "location", NULL, 8},
    {47, "max-forwards", NULL, 12},
    {48, "proxy-authenticate", NULL, 18},
    {49, "proxy-authorization", NULL, 19},
    {50, "range", NULL, 5},
    {51, "referer", NULL, 7},
    {52, "refresh", NULL, 7},
    {53, "retry-after", NULL, 11},
    {54, "server", NULL, 6},
    {55, "set-cookie", NULL, 10},
    {56, "strict-transport-security", NULL, 25},
    {57, "transfer-encoding", NULL, 17},
    {58, "user-agent", NULL, 10},
    {59, "vary", NULL, 4},
    {60, "via", NULL, 3},
    {61, "www-authenticate", NULL, 16}};

typedef struct hpack_huffman {
    /* (comment) */    /* ASCII symbol */
    /* (comment) */    /* code as bits aligned to MSB */
    unsigned int code; /* code as hex aligned to LSB */
    unsigned int len;  /* len in bits */
} hpack_huffman_t;
#define HPACK_HUFFMAN_SIZE (sizeof(huffman_table) / sizeof(huffman_table[0]))

static struct hpack_huffman huffman_table[] = {
    /* make the formatter happy*/
    {/*     (  0) |11111111|11000 */ 0x1ff8, 13},
    {/*     (  1) |11111111|11111111|1011000 */ 0x7fffd8, 23},
    {/*     (  2) |11111111|11111111|11111110|0010 */ 0xfffffe2, 28},
    {/*     (  3) |11111111|11111111|11111110|0011 */ 0xfffffe3, 28},
    {/*     (  4) |11111111|11111111|11111110|0100 */ 0xfffffe4, 28},
    {/*     (  5) |11111111|11111111|11111110|0101 */ 0xfffffe5, 28},
    {/*     (  6) |11111111|11111111|11111110|0110 */ 0xfffffe6, 28},
    {/*     (  7) |11111111|11111111|11111110|0111 */ 0xfffffe7, 28},
    {/*     (  8) |11111111|11111111|11111110|1000 */ 0xfffffe8, 28},
    {/*     (  9) |11111111|11111111|11101010 */ 0xffffea, 24},
    {/*     ( 10) |11111111|11111111|11111111|111100 */ 0x3ffffffc, 30},
    {/*     ( 11) |11111111|11111111|11111110|1001 */ 0xfffffe9, 28},
    {/*     ( 12) |11111111|11111111|11111110|1010 */ 0xfffffea, 28},
    {/*     ( 13) |11111111|11111111|11111111|111101 */ 0x3ffffffd, 30},
    {/*     ( 14) |11111111|11111111|11111110|1011 */ 0xfffffeb, 28},
    {/*     ( 15) |11111111|11111111|11111110|1100 */ 0xfffffec, 28},
    {/*     ( 16) |11111111|11111111|11111110|1101 */ 0xfffffed, 28},
    {/*     ( 17) |11111111|11111111|11111110|1110 */ 0xfffffee, 28},
    {/*     ( 18) |11111111|11111111|11111110|1111 */ 0xfffffef, 28},
    {/*     ( 19) |11111111|11111111|11111111|0000 */ 0xffffff0, 28},
    {/*     ( 20) |11111111|11111111|11111111|0001 */ 0xffffff1, 28},
    {/*     ( 21) |11111111|11111111|11111111|0010 */ 0xffffff2, 28},
    {/*     ( 22) |11111111|11111111|11111111|111110 */ 0x3ffffffe, 30},
    {/*     ( 23) |11111111|11111111|11111111|0011 */ 0xffffff3, 28},
    {/*     ( 24) |11111111|11111111|11111111|0100 */ 0xffffff4, 28},
    {/*     ( 25) |11111111|11111111|11111111|0101 */ 0xffffff5, 28},
    {/*     ( 26) |11111111|11111111|11111111|0110 */ 0xffffff6, 28},
    {/*     ( 27) |11111111|11111111|11111111|0111 */ 0xffffff7, 28},
    {/*     ( 28) |11111111|11111111|11111111|1000 */ 0xffffff8, 28},
    {/*     ( 29) |11111111|11111111|11111111|1001 */ 0xffffff9, 28},
    {/*     ( 30) |11111111|11111111|11111111|1010 */ 0xffffffa, 28},
    {/*     ( 31) |11111111|11111111|11111111|1011 */ 0xffffffb, 28},
    {/* ' ' ( 32) |010100 */ 0x14, 6},
    {/* '!' ( 33) |11111110|00 */ 0x3f8, 10},
    {/* '"' ( 34) |11111110|01 */ 0x3f9, 10},
    {/* '#' ( 35) |11111111|1010 */ 0xffa, 12},
    {/* '$' ( 36) |11111111|11001 */ 0x1ff9, 13},
    {/* '%' ( 37) |010101 */ 0x15, 6},
    {/* '&' ( 38) |11111000 */ 0xf8, 8},
    {/* ''' ( 39) |11111111|010 */ 0x7fa, 11},
    {/* '(' ( 40) |11111110|10 */ 0x3fa, 10},
    {/* ')' ( 41) |11111110|11 */ 0x3fb, 10},
    {/* '*' ( 42) |11111001 */ 0xf9, 8},
    {/* '+' ( 43) |11111111|011 */ 0x7fb, 11},
    {/* ',' ( 44) |11111010 */ 0xfa, 8},
    {/* '-' ( 45) |010110 */ 0x16, 6},
    {/* '.' ( 46) |010111 */ 0x17, 6},
    {/* '/' ( 47) |011000 */ 0x18, 6},
    {/* '0' ( 48) |00000 */ 0x0, 5},
    {/* '1' ( 49) |00001 */ 0x1, 5},
    {/* '2' ( 50) |00010 */ 0x2, 5},
    {/* '3' ( 51) |011001 */ 0x19, 6},
    {/* '4' ( 52) |011010 */ 0x1a, 6},
    {/* '5' ( 53) |011011 */ 0x1b, 6},
    {/* '6' ( 54) |011100 */ 0x1c, 6},
    {/* '7' ( 55) |011101 */ 0x1d, 6},
    {/* '8' ( 56) |011110 */ 0x1e, 6},
    {/* '9' ( 57) |011111 */ 0x1f, 6},
    {/* ':' ( 58) |1011100 */ 0x5c, 7},
    {/* ';' ( 59) |11111011 */ 0xfb, 8},
    {/* '<' ( 60) |11111111|1111100 */ 0x7ffc, 15},
    {/* '=' ( 61) |100000 */ 0x20, 6},
    {/* '>' ( 62) |11111111|1011 */ 0xffb, 12},
    {/* '?' ( 63) |11111111|00 */ 0x3fc, 10},
    {/* '@' ( 64) |11111111|11010 */ 0x1ffa, 13},
    {/* 'A' ( 65) |100001 */ 0x21, 6},
    {/* 'B' ( 66) |1011101 */ 0x5d, 7},
    {/* 'C' ( 67) |1011110 */ 0x5e, 7},
    {/* 'D' ( 68) |1011111 */ 0x5f, 7},
    {/* 'E' ( 69) |1100000 */ 0x60, 7},
    {/* 'F' ( 70) |1100001 */ 0x61, 7},
    {/* 'G' ( 71) |1100010 */ 0x62, 7},
    {/* 'H' ( 72) |1100011 */ 0x63, 7},
    {/* 'I' ( 73) |1100100 */ 0x64, 7},
    {/* 'J' ( 74) |1100101 */ 0x65, 7},
    {/* 'K' ( 75) |1100110 */ 0x66, 7},
    {/* 'L' ( 76) |1100111 */ 0x67, 7},
    {/* 'M' ( 77) |1101000 */ 0x68, 7},
    {/* 'N' ( 78) |1101001 */ 0x69, 7},
    {/* 'O' ( 79) |1101010 */ 0x6a, 7},
    {/* 'P' ( 80) |1101011 */ 0x6b, 7},
    {/* 'Q' ( 81) |1101100 */ 0x6c, 7},
    {/* 'R' ( 82) |1101101 */ 0x6d, 7},
    {/* 'S' ( 83) |1101110 */ 0x6e, 7},
    {/* 'T' ( 84) |1101111 */ 0x6f, 7},
    {/* 'U' ( 85) |1110000 */ 0x70, 7},
    {/* 'V' ( 86) |1110001 */ 0x71, 7},
    {/* 'W' ( 87) |1110010 */ 0x72, 7},
    {/* 'X' ( 88) |11111100 */ 0xfc, 8},
    {/* 'Y' ( 89) |1110011 */ 0x73, 7},
    {/* 'Z' ( 90) |11111101 */ 0xfd, 8},
    {/* '[' ( 91) |11111111|11011 */ 0x1ffb, 13},
    {/* '\' ( 92) |11111111|11111110|000 */ 0x7fff0, 19},
    {/* '}' ( 93) |11111111|11100 */ 0x1ffc, 13},
    {/* '^' ( 94) |11111111|111100 */ 0x3ffc, 14},
    {/* '_' ( 95) |100010 */ 0x22, 6},
    {/* '`' ( 96) |11111111|1111101 */ 0x7ffd, 15},
    {/* 'a' ( 97) |00011 */ 0x3, 5},
    {/* 'b' ( 98) |100011 */ 0x23, 6},
    {/* 'c' ( 99) |00100 */ 0x4, 5},
    {/* 'd' (100) |100100 */ 0x24, 6},
    {/* 'e' (101) |00101 */ 0x5, 5},
    {/* 'f' (102) |100101 */ 0x25, 6},
    {/* 'g' (103) |100110 */ 0x26, 6},
    {/* 'h' (104) |100111 */ 0x27, 6},
    {/* 'i' (105) |00110 */ 0x6, 5},
    {/* 'j' (106) |1110100 */ 0x74, 7},
    {/* 'k' (107) |1110101 */ 0x75, 7},
    {/* 'l' (108) |101000 */ 0x28, 6},
    {/* 'm' (109) |101001 */ 0x29, 6},
    {/* 'n' (110) |101010 */ 0x2a, 6},
    {/* 'o' (111) |00111 */ 0x7, 5},
    {/* 'p' (112) |101011 */ 0x2b, 6},
    {/* 'q' (113) |1110110 */ 0x76, 7},
    {/* 'r' (114) |101100 */ 0x2c, 6},
    {/* 's' (115) |01000 */ 0x8, 5},
    {/* 't' (116) |01001 */ 0x9, 5},
    {/* 'u' (117) |101101 */ 0x2d, 6},
    {/* 'v' (118) |1110111 */ 0x77, 7},
    {/* 'w' (119) |1111000 */ 0x78, 7},
    {/* 'x' (120) |1111001 */ 0x79, 7},
    {/* 'y' (121) |1111010 */ 0x7a, 7},
    {/* 'z' (122) |1111011 */ 0x7b, 7},
    {/* '{' (123) |11111111|1111110 */ 0x7ffe, 15},
    {/* '|' (124) |11111111|100 */ 0x7fc, 11},
    {/* '}' (125) |11111111|111101 */ 0x3ffd, 14},
    {/* '~' (126) |11111111|11101 */ 0x1ffd, 13},
    {/*     (127) |11111111|11111111|11111111|1100 */ 0xffffffc, 28},
    {/*     (128) |11111111|11111110|0110 */ 0xfffe6, 20},
    {/*     (129) |11111111|11111111|010010 */ 0x3fffd2, 22},
    {/*     (130) |11111111|11111110|0111 */ 0xfffe7, 20},
    {/*     (131) |11111111|11111110|1000 */ 0xfffe8, 20},
    {/*     (132) |11111111|11111111|010011 */ 0x3fffd3, 22},
    {/*     (133) |11111111|11111111|010100 */ 0x3fffd4, 22},
    {/*     (134) |11111111|11111111|010101 */ 0x3fffd5, 22},
    {/*     (135) |11111111|11111111|1011001 */ 0x7fffd9, 23},
    {/*     (136) |11111111|11111111|010110 */ 0x3fffd6, 22},
    {/*     (137) |11111111|11111111|1011010 */ 0x7fffda, 23},
    {/*     (138) |11111111|11111111|1011011 */ 0x7fffdb, 23},
    {/*     (139) |11111111|11111111|1011100 */ 0x7fffdc, 23},
    {/*     (140) |11111111|11111111|1011101 */ 0x7fffdd, 23},
    {/*     (141) |11111111|11111111|1011110 */ 0x7fffde, 23},
    {/*     (142) |11111111|11111111|11101011 */ 0xffffeb, 24},
    {/*     (143) |11111111|11111111|1011111 */ 0x7fffdf, 23},
    {/*     (144) |11111111|11111111|11101100 */ 0xffffec, 24},
    {/*     (145) |11111111|11111111|11101101 */ 0xffffed, 24},
    {/*     (146) |11111111|11111111|010111 */ 0x3fffd7, 22},
    {/*     (147) |11111111|11111111|1100000 */ 0x7fffe0, 23},
    {/*     (148) |11111111|11111111|11101110 */ 0xffffee, 24},
    {/*     (149) |11111111|11111111|1100001 */ 0x7fffe1, 23},
    {/*     (150) |11111111|11111111|1100010 */ 0x7fffe2, 23},
    {/*     (151) |11111111|11111111|1100011 */ 0x7fffe3, 23},
    {/*     (152) |11111111|11111111|1100100 */ 0x7fffe4, 23},
    {/*     (153) |11111111|11111110|11100 */ 0x1fffdc, 21},
    {/*     (154) |11111111|11111111|011000 */ 0x3fffd8, 22},
    {/*     (155) |11111111|11111111|1100101 */ 0x7fffe5, 23},
    {/*     (156) |11111111|11111111|011001 */ 0x3fffd9, 22},
    {/*     (157) |11111111|11111111|1100110 */ 0x7fffe6, 23},
    {/*     (158) |11111111|11111111|1100111 */ 0x7fffe7, 23},
    {/*     (159) |11111111|11111111|11101111 */ 0xffffef, 24},
    {/*     (160) |11111111|11111111|011010 */ 0x3fffda, 22},
    {/*     (161) |11111111|11111110|11101 */ 0x1fffdd, 21},
    {/*     (162) |11111111|11111110|1001 */ 0xfffe9, 20},
    {/*     (163) |11111111|11111111|011011 */ 0x3fffdb, 22},
    {/*     (164) |11111111|11111111|011100 */ 0x3fffdc, 22},
    {/*     (165) |11111111|11111111|1101000 */ 0x7fffe8, 23},
    {/*     (166) |11111111|11111111|1101001 */ 0x7fffe9, 23},
    {/*     (167) |11111111|11111110|11110 */ 0x1fffde, 21},
    {/*     (168) |11111111|11111111|1101010 */ 0x7fffea, 23},
    {/*     (169) |11111111|11111111|011101 */ 0x3fffdd, 22},
    {/*     (170) |11111111|11111111|011110 */ 0x3fffde, 22},
    {/*     (171) |11111111|11111111|11110000 */ 0xfffff0, 24},
    {/*     (172) |11111111|11111110|11111 */ 0x1fffdf, 21},
    {/*     (173) |11111111|11111111|011111 */ 0x3fffdf, 22},
    {/*     (174) |11111111|11111111|1101011 */ 0x7fffeb, 23},
    {/*     (175) |11111111|11111111|1101100 */ 0x7fffec, 23},
    {/*     (176) |11111111|11111111|00000 */ 0x1fffe0, 21},
    {/*     (177) |11111111|11111111|00001 */ 0x1fffe1, 21},
    {/*     (178) |11111111|11111111|100000 */ 0x3fffe0, 22},
    {/*     (179) |11111111|11111111|00010 */ 0x1fffe2, 21},
    {/*     (180) |11111111|11111111|1101101 */ 0x7fffed, 23},
    {/*     (181) |11111111|11111111|100001 */ 0x3fffe1, 22},
    {/*     (182) |11111111|11111111|1101110 */ 0x7fffee, 23},
    {/*     (183) |11111111|11111111|1101111 */ 0x7fffef, 23},
    {/*     (184) |11111111|11111110|1010 */ 0xfffea, 20},
    {/*     (185) |11111111|11111111|100010 */ 0x3fffe2, 22},
    {/*     (186) |11111111|11111111|100011 */ 0x3fffe3, 22},
    {/*     (187) |11111111|11111111|100100 */ 0x3fffe4, 22},
    {/*     (188) |11111111|11111111|1110000 */ 0x7ffff0, 23},
    {/*     (189) |11111111|11111111|100101 */ 0x3fffe5, 22},
    {/*     (190) |11111111|11111111|100110 */ 0x3fffe6, 22},
    {/*     (191) |11111111|11111111|1110001 */ 0x7ffff1, 23},
    {/*     (192) |11111111|11111111|11111000|00 */ 0x3ffffe0, 26},
    {/*     (193) |11111111|11111111|11111000|01 */ 0x3ffffe1, 26},
    {/*     (194) |11111111|11111110|1011 */ 0xfffeb, 20},
    {/*     (195) |11111111|11111110|001 */ 0x7fff1, 19},
    {/*     (196) |11111111|11111111|100111 */ 0x3fffe7, 22},
    {/*     (197) |11111111|11111111|1110010 */ 0x7ffff2, 23},
    {/*     (198) |11111111|11111111|101000 */ 0x3fffe8, 22},
    {/*     (199) |11111111|11111111|11110110|0 */ 0x1ffffec, 25},
    {/*     (200) |11111111|11111111|11111000|10 */ 0x3ffffe2, 26},
    {/*     (201) |11111111|11111111|11111000|11 */ 0x3ffffe3, 26},
    {/*     (202) |11111111|11111111|11111001|00 */ 0x3ffffe4, 26},
    {/*     (203) |11111111|11111111|11111011|110 */ 0x7ffffde, 27},
    {/*     (204) |11111111|11111111|11111011|111 */ 0x7ffffdf, 27},
    {/*     (205) |11111111|11111111|11111001|01 */ 0x3ffffe5, 26},
    {/*     (206) |11111111|11111111|11110001 */ 0xfffff1, 24},
    {/*     (207) |11111111|11111111|11110110|1 */ 0x1ffffed, 25},
    {/*     (208) |11111111|11111110|010 */ 0x7fff2, 19},
    {/*     (209) |11111111|11111111|00011 */ 0x1fffe3, 21},
    {/*     (210) |11111111|11111111|11111001|10 */ 0x3ffffe6, 26},
    {/*     (211) |11111111|11111111|11111100|000 */ 0x7ffffe0, 27},
    {/*     (212) |11111111|11111111|11111100|001 */ 0x7ffffe1, 27},
    {/*     (213) |11111111|11111111|11111001|11 */ 0x3ffffe7, 26},
    {/*     (214) |11111111|11111111|11111100|010 */ 0x7ffffe2, 27},
    {/*     (215) |11111111|11111111|11110010 */ 0xfffff2, 24},
    {/*     (216) |11111111|11111111|00100 */ 0x1fffe4, 21},
    {/*     (217) |11111111|11111111|00101 */ 0x1fffe5, 21},
    {/*     (218) |11111111|11111111|11111010|00 */ 0x3ffffe8, 26},
    {/*     (219) |11111111|11111111|11111010|01 */ 0x3ffffe9, 26},
    {/*     (220) |11111111|11111111|11111111|1101 */ 0xffffffd, 28},
    {/*     (221) |11111111|11111111|11111100|011 */ 0x7ffffe3, 27},
    {/*     (222) |11111111|11111111|11111100|100 */ 0x7ffffe4, 27},
    {/*     (223) |11111111|11111111|11111100|101 */ 0x7ffffe5, 27},
    {/*     (224) |11111111|11111110|1100 */ 0xfffec, 20},
    {/*     (225) |11111111|11111111|11110011 */ 0xfffff3, 24},
    {/*     (226) |11111111|11111110|1101 */ 0xfffed, 20},
    {/*     (227) |11111111|11111111|00110 */ 0x1fffe6, 21},
    {/*     (228) |11111111|11111111|101001 */ 0x3fffe9, 22},
    {/*     (229) |11111111|11111111|00111 */ 0x1fffe7, 21},
    {/*     (230) |11111111|11111111|01000 */ 0x1fffe8, 21},
    {/*     (231) |11111111|11111111|1110011 */ 0x7ffff3, 23},
    {/*     (232) |11111111|11111111|101010 */ 0x3fffea, 22},
    {/*     (233) |11111111|11111111|101011 */ 0x3fffeb, 22},
    {/*     (234) |11111111|11111111|11110111|0 */ 0x1ffffee, 25},
    {/*     (235) |11111111|11111111|11110111|1 */ 0x1ffffef, 25},
    {/*     (236) |11111111|11111111|11110100 */ 0xfffff4, 24},
    {/*     (237) |11111111|11111111|11110101 */ 0xfffff5, 24},
    {/*     (238) |11111111|11111111|11111010|10 */ 0x3ffffea, 26},
    {/*     (239) |11111111|11111111|1110100 */ 0x7ffff4, 23},
    {/*     (240) |11111111|11111111|11111010|11 */ 0x3ffffeb, 26},
    {/*     (241) |11111111|11111111|11111100|110 */ 0x7ffffe6, 27},
    {/*     (242) |11111111|11111111|11111011|00 */ 0x3ffffec, 26},
    {/*     (243) |11111111|11111111|11111011|01 */ 0x3ffffed, 26},
    {/*     (244) |11111111|11111111|11111100|111 */ 0x7ffffe7, 27},
    {/*     (245) |11111111|11111111|11111101|000 */ 0x7ffffe8, 27},
    {/*     (246) |11111111|11111111|11111101|001 */ 0x7ffffe9, 27},
    {/*     (247) |11111111|11111111|11111101|010 */ 0x7ffffea, 27},
    {/*     (248) |11111111|11111111|11111101|011 */ 0x7ffffeb, 27},
    {/*     (249) |11111111|11111111|11111111|1110 */ 0xffffffe, 28},
    {/*     (250) |11111111|11111111|11111101|100 */ 0x7ffffec, 27},
    {/*     (251) |11111111|11111111|11111101|101 */ 0x7ffffed, 27},
    {/*     (252) |11111111|11111111|11111101|110 */ 0x7ffffee, 27},
    {/*     (253) |11111111|11111111|11111101|111 */ 0x7ffffef, 27},
    {/*     (254) |11111111|11111111|11111110|000 */ 0x7fffff0, 27},
    {/*     (255) |11111111|11111111|11111011|10 */ 0x3ffffee, 26},
    {/* EOS (256) |11111111|11111111|11111111|111111 */ 0x3fffffff, 30}};

typedef struct huffman_node {
    int index, left, right, sym;
} huffman_node_t;

static huffman_node_t huffman_tree[] = {
    /* make the formatter happy*/
    {0, 1, 44, -1},      {1, 2, 17, -1},      {2, 3, 10, -1},      {3, 4, 7, -1},       {4, 5, 6, -1},
    {5, -1, -1, 48},     {6, -1, -1, 49},     {7, 8, 9, -1},       {8, -1, -1, 50},     {9, -1, -1, 97},
    {10, 11, 14, -1},    {11, 12, 13, -1},    {12, -1, -1, 99},    {13, -1, -1, 101},   {14, 15, 16, -1},
    {15, -1, -1, 105},   {16, -1, -1, 111},   {17, 18, 29, -1},    {18, 19, 22, -1},    {19, 20, 21, -1},
    {20, -1, -1, 115},   {21, -1, -1, 116},   {22, 23, 26, -1},    {23, 24, 25, -1},    {24, -1, -1, 32},
    {25, -1, -1, 37},    {26, 27, 28, -1},    {27, -1, -1, 45},    {28, -1, -1, 46},    {29, 30, 37, -1},
    {30, 31, 34, -1},    {31, 32, 33, -1},    {32, -1, -1, 47},    {33, -1, -1, 51},    {34, 35, 36, -1},
    {35, -1, -1, 52},    {36, -1, -1, 53},    {37, 38, 41, -1},    {38, 39, 40, -1},    {39, -1, -1, 54},
    {40, -1, -1, 55},    {41, 42, 43, -1},    {42, -1, -1, 56},    {43, -1, -1, 57},    {44, 45, 80, -1},
    {45, 46, 61, -1},    {46, 47, 54, -1},    {47, 48, 51, -1},    {48, 49, 50, -1},    {49, -1, -1, 61},
    {50, -1, -1, 65},    {51, 52, 53, -1},    {52, -1, -1, 95},    {53, -1, -1, 98},    {54, 55, 58, -1},
    {55, 56, 57, -1},    {56, -1, -1, 100},   {57, -1, -1, 102},   {58, 59, 60, -1},    {59, -1, -1, 103},
    {60, -1, -1, 104},   {61, 62, 69, -1},    {62, 63, 66, -1},    {63, 64, 65, -1},    {64, -1, -1, 108},
    {65, -1, -1, 109},   {66, 67, 68, -1},    {67, -1, -1, 110},   {68, -1, -1, 112},   {69, 70, 73, -1},
    {70, 71, 72, -1},    {71, -1, -1, 114},   {72, -1, -1, 117},   {73, 74, 77, -1},    {74, 75, 76, -1},
    {75, -1, -1, 58},    {76, -1, -1, 66},    {77, 78, 79, -1},    {78, -1, -1, 67},    {79, -1, -1, 68},
    {80, 81, 112, -1},   {81, 82, 97, -1},    {82, 83, 90, -1},    {83, 84, 87, -1},    {84, 85, 86, -1},
    {85, -1, -1, 69},    {86, -1, -1, 70},    {87, 88, 89, -1},    {88, -1, -1, 71},    {89, -1, -1, 72},
    {90, 91, 94, -1},    {91, 92, 93, -1},    {92, -1, -1, 73},    {93, -1, -1, 74},    {94, 95, 96, -1},
    {95, -1, -1, 75},    {96, -1, -1, 76},    {97, 98, 105, -1},   {98, 99, 102, -1},   {99, 100, 101, -1},
    {100, -1, -1, 77},   {101, -1, -1, 78},   {102, 103, 104, -1}, {103, -1, -1, 79},   {104, -1, -1, 80},
    {105, 106, 109, -1}, {106, 107, 108, -1}, {107, -1, -1, 81},   {108, -1, -1, 82},   {109, 110, 111, -1},
    {110, -1, -1, 83},   {111, -1, -1, 84},   {112, 113, 128, -1}, {113, 114, 121, -1}, {114, 115, 118, -1},
    {115, 116, 117, -1}, {116, -1, -1, 85},   {117, -1, -1, 86},   {118, 119, 120, -1}, {119, -1, -1, 87},
    {120, -1, -1, 89},   {121, 122, 125, -1}, {122, 123, 124, -1}, {123, -1, -1, 106},  {124, -1, -1, 107},
    {125, 126, 127, -1}, {126, -1, -1, 113},  {127, -1, -1, 118},  {128, 129, 136, -1}, {129, 130, 133, -1},
    {130, 131, 132, -1}, {131, -1, -1, 119},  {132, -1, -1, 120},  {133, 134, 135, -1}, {134, -1, -1, 121},
    {135, -1, -1, 122},  {136, 137, 144, -1}, {137, 138, 141, -1}, {138, 139, 140, -1}, {139, -1, -1, 38},
    {140, -1, -1, 42},   {141, 142, 143, -1}, {142, -1, -1, 44},   {143, -1, -1, 59},   {144, 145, 148, -1},
    {145, 146, 147, -1}, {146, -1, -1, 88},   {147, -1, -1, 90},   {148, 149, 156, -1}, {149, 150, 153, -1},
    {150, 151, 152, -1}, {151, -1, -1, 33},   {152, -1, -1, 34},   {153, 154, 155, -1}, {154, -1, -1, 40},
    {155, -1, -1, 41},   {156, 157, 162, -1}, {157, 158, 159, -1}, {158, -1, -1, 63},   {159, 160, 161, -1},
    {160, -1, -1, 39},   {161, -1, -1, 43},   {162, 163, 168, -1}, {163, 164, 165, -1}, {164, -1, -1, 124},
    {165, 166, 167, -1}, {166, -1, -1, 35},   {167, -1, -1, 62},   {168, 169, 176, -1}, {169, 170, 173, -1},
    {170, 171, 172, -1}, {171, -1, -1, 0},    {172, -1, -1, 36},   {173, 174, 175, -1}, {174, -1, -1, 64},
    {175, -1, -1, 91},   {176, 177, 180, -1}, {177, 178, 179, -1}, {178, -1, -1, 93},   {179, -1, -1, 126},
    {180, 181, 184, -1}, {181, 182, 183, -1}, {182, -1, -1, 94},   {183, -1, -1, 125},  {184, 185, 188, -1},
    {185, 186, 187, -1}, {186, -1, -1, 60},   {187, -1, -1, 96},   {188, 189, 190, -1}, {189, -1, -1, 123},
    {190, 191, 220, -1}, {191, 192, 201, -1}, {192, 193, 196, -1}, {193, 194, 195, -1}, {194, -1, -1, 92},
    {195, -1, -1, 195},  {196, 197, 198, -1}, {197, -1, -1, 208},  {198, 199, 200, -1}, {199, -1, -1, 128},
    {200, -1, -1, 130},  {201, 202, 209, -1}, {202, 203, 206, -1}, {203, 204, 205, -1}, {204, -1, -1, 131},
    {205, -1, -1, 162},  {206, 207, 208, -1}, {207, -1, -1, 184},  {208, -1, -1, 194},  {209, 210, 213, -1},
    {210, 211, 212, -1}, {211, -1, -1, 224},  {212, -1, -1, 226},  {213, 214, 217, -1}, {214, 215, 216, -1},
    {215, -1, -1, 153},  {216, -1, -1, 161},  {217, 218, 219, -1}, {218, -1, -1, 167},  {219, -1, -1, 172},
    {220, 221, 266, -1}, {221, 222, 237, -1}, {222, 223, 230, -1}, {223, 224, 227, -1}, {224, 225, 226, -1},
    {225, -1, -1, 176},  {226, -1, -1, 177},  {227, 228, 229, -1}, {228, -1, -1, 179},  {229, -1, -1, 209},
    {230, 231, 234, -1}, {231, 232, 233, -1}, {232, -1, -1, 216},  {233, -1, -1, 217},  {234, 235, 236, -1},
    {235, -1, -1, 227},  {236, -1, -1, 229},  {237, 238, 251, -1}, {238, 239, 244, -1}, {239, 240, 241, -1},
    {240, -1, -1, 230},  {241, 242, 243, -1}, {242, -1, -1, 129},  {243, -1, -1, 132},  {244, 245, 248, -1},
    {245, 246, 247, -1}, {246, -1, -1, 133},  {247, -1, -1, 134},  {248, 249, 250, -1}, {249, -1, -1, 136},
    {250, -1, -1, 146},  {251, 252, 259, -1}, {252, 253, 256, -1}, {253, 254, 255, -1}, {254, -1, -1, 154},
    {255, -1, -1, 156},  {256, 257, 258, -1}, {257, -1, -1, 160},  {258, -1, -1, 163},  {259, 260, 263, -1},
    {260, 261, 262, -1}, {261, -1, -1, 164},  {262, -1, -1, 169},  {263, 264, 265, -1}, {264, -1, -1, 170},
    {265, -1, -1, 173},  {266, 267, 306, -1}, {267, 268, 283, -1}, {268, 269, 276, -1}, {269, 270, 273, -1},
    {270, 271, 272, -1}, {271, -1, -1, 178},  {272, -1, -1, 181},  {273, 274, 275, -1}, {274, -1, -1, 185},
    {275, -1, -1, 186},  {276, 277, 280, -1}, {277, 278, 279, -1}, {278, -1, -1, 187},  {279, -1, -1, 189},
    {280, 281, 282, -1}, {281, -1, -1, 190},  {282, -1, -1, 196},  {283, 284, 291, -1}, {284, 285, 288, -1},
    {285, 286, 287, -1}, {286, -1, -1, 198},  {287, -1, -1, 228},  {288, 289, 290, -1}, {289, -1, -1, 232},
    {290, -1, -1, 233},  {291, 292, 299, -1}, {292, 293, 296, -1}, {293, 294, 295, -1}, {294, -1, -1, 1},
    {295, -1, -1, 135},  {296, 297, 298, -1}, {297, -1, -1, 137},  {298, -1, -1, 138},  {299, 300, 303, -1},
    {300, 301, 302, -1}, {301, -1, -1, 139},  {302, -1, -1, 140},  {303, 304, 305, -1}, {304, -1, -1, 141},
    {305, -1, -1, 143},  {306, 307, 338, -1}, {307, 308, 323, -1}, {308, 309, 316, -1}, {309, 310, 313, -1},
    {310, 311, 312, -1}, {311, -1, -1, 147},  {312, -1, -1, 149},  {313, 314, 315, -1}, {314, -1, -1, 150},
    {315, -1, -1, 151},  {316, 317, 320, -1}, {317, 318, 319, -1}, {318, -1, -1, 152},  {319, -1, -1, 155},
    {320, 321, 322, -1}, {321, -1, -1, 157},  {322, -1, -1, 158},  {323, 324, 331, -1}, {324, 325, 328, -1},
    {325, 326, 327, -1}, {326, -1, -1, 165},  {327, -1, -1, 166},  {328, 329, 330, -1}, {329, -1, -1, 168},
    {330, -1, -1, 174},  {331, 332, 335, -1}, {332, 333, 334, -1}, {333, -1, -1, 175},  {334, -1, -1, 180},
    {335, 336, 337, -1}, {336, -1, -1, 182},  {337, -1, -1, 183},  {338, 339, 360, -1}, {339, 340, 347, -1},
    {340, 341, 344, -1}, {341, 342, 343, -1}, {342, -1, -1, 188},  {343, -1, -1, 191},  {344, 345, 346, -1},
    {345, -1, -1, 197},  {346, -1, -1, 231},  {347, 348, 353, -1}, {348, 349, 350, -1}, {349, -1, -1, 239},
    {350, 351, 352, -1}, {351, -1, -1, 9},    {352, -1, -1, 142},  {353, 354, 357, -1}, {354, 355, 356, -1},
    {355, -1, -1, 144},  {356, -1, -1, 145},  {357, 358, 359, -1}, {358, -1, -1, 148},  {359, -1, -1, 159},
    {360, 361, 380, -1}, {361, 362, 369, -1}, {362, 363, 366, -1}, {363, 364, 365, -1}, {364, -1, -1, 171},
    {365, -1, -1, 206},  {366, 367, 368, -1}, {367, -1, -1, 215},  {368, -1, -1, 225},  {369, 370, 373, -1},
    {370, 371, 372, -1}, {371, -1, -1, 236},  {372, -1, -1, 237},  {373, 374, 377, -1}, {374, 375, 376, -1},
    {375, -1, -1, 199},  {376, -1, -1, 207},  {377, 378, 379, -1}, {378, -1, -1, 234},  {379, -1, -1, 235},
    {380, 381, 414, -1}, {381, 382, 397, -1}, {382, 383, 390, -1}, {383, 384, 387, -1}, {384, 385, 386, -1},
    {385, -1, -1, 192},  {386, -1, -1, 193},  {387, 388, 389, -1}, {388, -1, -1, 200},  {389, -1, -1, 201},
    {390, 391, 394, -1}, {391, 392, 393, -1}, {392, -1, -1, 202},  {393, -1, -1, 205},  {394, 395, 396, -1},
    {395, -1, -1, 210},  {396, -1, -1, 213},  {397, 398, 405, -1}, {398, 399, 402, -1}, {399, 400, 401, -1},
    {400, -1, -1, 218},  {401, -1, -1, 219},  {402, 403, 404, -1}, {403, -1, -1, 238},  {404, -1, -1, 240},
    {405, 406, 409, -1}, {406, 407, 408, -1}, {407, -1, -1, 242},  {408, -1, -1, 243},  {409, 410, 411, -1},
    {410, -1, -1, 255},  {411, 412, 413, -1}, {412, -1, -1, 203},  {413, -1, -1, 204},  {414, 415, 446, -1},
    {415, 416, 431, -1}, {416, 417, 424, -1}, {417, 418, 421, -1}, {418, 419, 420, -1}, {419, -1, -1, 211},
    {420, -1, -1, 212},  {421, 422, 423, -1}, {422, -1, -1, 214},  {423, -1, -1, 221},  {424, 425, 428, -1},
    {425, 426, 427, -1}, {426, -1, -1, 222},  {427, -1, -1, 223},  {428, 429, 430, -1}, {429, -1, -1, 241},
    {430, -1, -1, 244},  {431, 432, 439, -1}, {432, 433, 436, -1}, {433, 434, 435, -1}, {434, -1, -1, 245},
    {435, -1, -1, 246},  {436, 437, 438, -1}, {437, -1, -1, 247},  {438, -1, -1, 248},  {439, 440, 443, -1},
    {440, 441, 442, -1}, {441, -1, -1, 250},  {442, -1, -1, 251},  {443, 444, 445, -1}, {444, -1, -1, 252},
    {445, -1, -1, 253},  {446, 447, 476, -1}, {447, 448, 461, -1}, {448, 449, 454, -1}, {449, 450, 451, -1},
    {450, -1, -1, 254},  {451, 452, 453, -1}, {452, -1, -1, 2},    {453, -1, -1, 3},    {454, 455, 458, -1},
    {455, 456, 457, -1}, {456, -1, -1, 4},    {457, -1, -1, 5},    {458, 459, 460, -1}, {459, -1, -1, 6},
    {460, -1, -1, 7},    {461, 462, 469, -1}, {462, 463, 466, -1}, {463, 464, 465, -1}, {464, -1, -1, 8},
    {465, -1, -1, 11},   {466, 467, 468, -1}, {467, -1, -1, 12},   {468, -1, -1, 14},   {469, 470, 473, -1},
    {470, 471, 472, -1}, {471, -1, -1, 15},   {472, -1, -1, 16},   {473, 474, 475, -1}, {474, -1, -1, 17},
    {475, -1, -1, 18},   {476, 477, 492, -1}, {477, 478, 485, -1}, {478, 479, 482, -1}, {479, 480, 481, -1},
    {480, -1, -1, 19},   {481, -1, -1, 20},   {482, 483, 484, -1}, {483, -1, -1, 21},   {484, -1, -1, 23},
    {485, 486, 489, -1}, {486, 487, 488, -1}, {487, -1, -1, 24},   {488, -1, -1, 25},   {489, 490, 491, -1},
    {490, -1, -1, 26},   {491, -1, -1, 27},   {492, 493, 500, -1}, {493, 494, 497, -1}, {494, 495, 496, -1},
    {495, -1, -1, 28},   {496, -1, -1, 29},   {497, 498, 499, -1}, {498, -1, -1, 30},   {499, -1, -1, 31},
    {500, 501, 504, -1}, {501, 502, 503, -1}, {502, -1, -1, 127},  {503, -1, -1, 220},  {504, 505, 506, -1},
    {505, -1, -1, 249},  {506, 507, 510, -1}, {507, 508, 509, -1}, {508, -1, -1, 10},   {509, -1, -1, 13},
    {510, 511, 512, -1}, {511, -1, -1, 22},   {512, -1, -1, 256}};

typedef struct hpack_stream {
    byte *buf;
    size_t off, max;
} hpack_stream_t;

/* Masks, flags, and prefixes of the field types */
#define HPACK_M_INDEX 0x80               /* 7-bit prefix */
#define HPACK_F_INDEX 0x80               /* index flag */
#define HPACK_M_LITERAL_INDEX 0xc0       /* 6-bit prefix */
#define HPACK_F_LITERAL_INDEX 0x40       /* literal index flag */
#define HPACK_M_LITERAL_NO_INDEX 0xf0    /* 4-bit prefix */
#define HPACK_F_LITERAL_NO_INDEX 0x00    /* no index flag */
#define HPACK_M_LITERAL_NEVER_INDEX 0xf0 /* 4-bit prefix */
#define HPACK_F_LITERAL_NEVER_INDEX 0x10 /* never index flag */
#define HPACK_M_TABLE_SIZE_UPDATE 0xe0   /* 5-bit prefix */
#define HPACK_F_TABLE_SIZE_UPDATE 0x20   /* dynamic table size flag */
#define HPACK_M_LITERAL 0x80             /* 7-bit index */
#define HPACK_F_LITERAL 0x00             /* literal encoding */
#define HPACK_F_LITERAL_HUFFMAN 0x80     /* huffman encoding */

/* stream functions start */
int hpack_peek_char(hpack_stream_t *s, byte *out) {
    if (hpack_likely(s->off < s->max)) {
        *out = s->buf[s->off];
        return HPACK_ERROR_NO_ERR;
    }
    return HPACK_ERROR_DECODE_ERROR;
}

int hpack_read_char(hpack_stream_t *s, byte *out) {
    if (hpack_likely(s->off < s->max)) {
        *out = s->buf[s->off++];
        return HPACK_ERROR_NO_ERR;
    }
    return HPACK_ERROR_DECODE_ERROR;
}

int hpack_drain(hpack_stream_t *s, byte split) {
    while (s->off < s->max && s->buf[s->off] != split) s->off++;
    if (hpack_likely(s->off < s->max)) s->off++;  // skip the split
    return HPACK_ERROR_NO_ERR;
}

int hpack_strlen(hpack_stream_t *s, byte split, int *out_len) {
    int off = s->off;
    while (off < s->max && s->buf[off] != split) off++;
    *out_len = off - s->off;
    return HPACK_ERROR_NO_ERR;
}

int hpack_has_str(hpack_stream_t *s, size_t len) {
    if (hpack_unlikely(s->off + len > s->max)) return HPACK_ERROR_DECODE_ERROR;
    return HPACK_ERROR_NO_ERR;
}

int hpack_write_char(hpack_stream_t *s, const byte chr) {
    if (hpack_likely(s->off < s->max)) {
        s->buf[s->off++] = chr;
        return HPACK_ERROR_NO_ERR;
    }
    return HPACK_ERROR_NO_MEMORY;
}

int hpack_write_str(hpack_stream_t *s, const byte *str, size_t len) {
    if (hpack_unlikely(s->off + len > s->max)) {
        return HPACK_ERROR_NO_MEMORY;
    }
    memcpy(s->buf + s->off, str, len);
    s->off += len;
    return HPACK_ERROR_NO_ERR;
}

int hpack_write_string(hpack_stream_t *s, const byte *str) { return hpack_write_str(s, str, strlen(str)); }

int hpack_erase_last_value(hpack_stream_t *s) {
    int off = s->off;
    while (off && s->buf[off--] != SPLIT_1)
        ;
    // if (off == 0), then it means that either we can't find the SPLIT_1,
    // or the SPLIT_1 locates @ index 1
    // since we don't have a key that contains only 1 char
    // we can simplify the test to (off != 0)
    if (hpack_unlikely(!off)) return HPACK_ERROR_DECODE_ERROR;
    s->off = off + 2;  // skip the SPLIT_1
    return HPACK_ERROR_NO_ERR;
}

/* stream functions end*/

/* huffman function start */
int hpack_huffman_decode_str(hpack_stream_t *in, int len, hpack_stream_t *out) {
    byte code;
    int node = 0;
    for (int i = 0; i < len; i++) {
        HANDLE_ERROR(hpack_read_char(in, &code));

        /* Walk the Huffman tree for each bit in the encoded input */
        for (int j = 8; j > 0; j--) {
            if ((code >> (j - 1)) & 1)
                node = huffman_tree[node].right;
            else
                node = huffman_tree[node].left;
            if (huffman_tree[node].sym == -1) continue;

            /* Leaf node of the next (8-bit ASCII) symbol */
            HANDLE_ERROR(hpack_write_char(out, huffman_tree[node].sym));
            node = 0;
        }
    }
    return HPACK_ERROR_NO_ERR;
}

int hpack_huffman_calc_encode_len(hpack_stream_t *in, int len) {
    byte c;
    int i;
    hpack_huffman_t *hph;

    int encoded_len = 0;
    float bit_len = 0;

    for (i = 0; i < len; i++) {
        c = in->buf[in->off + i];
        hph = &huffman_table[c];
        bit_len += hph->len;
    }
    encoded_len = ceil(bit_len / 8);
    return encoded_len;
}

int hpack_huffman_encode_str(hpack_stream_t *in, int len, hpack_stream_t *out) {
    byte c;
    byte o, obits;
    int i, code;
    hpack_huffman_t *hph;

    for (i = 0, o = 0, obits = 8; i < len; i++) {
        int j;
        /* Get Huffman code for each (8-bit ASCII) symbol */
        HANDLE_ERROR(hpack_read_char(in, &c));
        hph = &huffman_table[c];

        for (code = hph->code, j = hph->len; j > 0;) {
            if (j > obits) {
                /* More bits to encode for this symbol */
                j -= obits;
                o |= (code >> j) & 0xff;
                obits = 0;
            } else {
                /*
                 * Remaining bits to encode for this input
                 * symbol.  The current output octet will
                 * include bits from the next symbol or padding.
                 */
                obits -= j;
                o |= (code << obits) & 0xff;
                j = 0;
            }
            if (obits == 0) {
                HANDLE_ERROR(hpack_write_char(out, o));
                o = 0;
                obits = 8;
            }
        }
    }

    if (len && obits > 0 && obits < 8) {
        /* Pad last octet with ones (EOS) */
        o |= (1 << obits) - 1;
        HANDLE_ERROR(hpack_write_char(out, o));
    }

    return HPACK_ERROR_NO_ERR;
}
/* huffman function end */

/* decode fucntion start */
int hpack_decode_int(hpack_stream_t *in, byte prefix, int *out_int) {
    int i = 0;
    byte b = 0, m;

    HANDLE_ERROR(hpack_read_char(in, &b));
    m = ~prefix;
    i = b & m;

    if (i >= m) {
        m = 0;
        /* Read varint bits while the 0x80 bit is set */
        do {
            if (i > INT_MAX) return (-1);
            HANDLE_ERROR(hpack_read_char(in, &b));
            i += (b & ~0x80) << m;
            m += 7;
        } while (b & 0x80);
    }

    *out_int = i;
    return HPACK_ERROR_NO_ERR;
}

int hpack_decode_str(hpack_stream_t *in, byte prefix, hpack_stream_t *out, byte end) {
    byte c;
    int len;

    HANDLE_ERROR(hpack_peek_char(in, &c));
    HANDLE_ERROR(hpack_decode_int(in, prefix, &len));

    if (HPACK_F_LITERAL_HUFFMAN == (c & HPACK_M_LITERAL)) {
        HANDLE_ERROR(hpack_huffman_decode_str(in, len, out));
    } else {
        HANDLE_ERROR(hpack_has_str(in, len));
        HANDLE_ERROR(hpack_write_str(out, in->buf + in->off, len));
        in->off += len;
    }
    if (hpack_likely(end)) HANDLE_ERROR(hpack_write_char(out, end));
    return HPACK_ERROR_NO_ERR;
}

int hpack_decode_index(hpack_stream_t *in, byte prefix, hpack_stream_t *out, int *out_index) {
    int i;

    HANDLE_ERROR(hpack_decode_int(in, prefix, &i));

    if (i > HPACK_STATIC_SIZE) {
        return HPACK_ERROR_DECODE_ERROR;
    }

    if (!i) {
        if (out_index) *out_index = 0;
        return HPACK_ERROR_NO_ERR;
    }

    HANDLE_ERROR(hpack_write_string(out, static_table[i - 1].name));
    HANDLE_ERROR(hpack_write_char(out, SPLIT_1));
    if (static_table[i - 1].value) {
        HANDLE_ERROR(hpack_write_string(out, static_table[i - 1].value));
    }
    HANDLE_ERROR(hpack_write_char(out, SPLIT_2));
    if (out_index) *out_index = i;

    return HPACK_ERROR_NO_ERR;
}

int hpack_decode_literal(hpack_stream_t *in, byte prefix, hpack_stream_t *out) {
    int i;
    HANDLE_ERROR(hpack_decode_index(in, prefix, out, &i));

    if (!i) {
        // decode the key
        HANDLE_ERROR(hpack_decode_str(in, HPACK_M_LITERAL, out, SPLIT_1));
    } else {
        // there the value field shall be already filled,
        // let's remove it.
        HANDLE_ERROR(hpack_erase_last_value(out));
    }
    HANDLE_ERROR(hpack_decode_str(in, HPACK_M_LITERAL, out, SPLIT_2));
}

int hpack_decode_incremental(hpack_stream_t *in, hpack_stream_t *out) {
    byte c;

    HANDLE_ERROR(hpack_peek_char(in, &c));

    /* 6.1 Indexed Header Field Representation */
    if ((c & HPACK_M_INDEX) == HPACK_F_INDEX) {
        /* 7 bit index */
        HANDLE_ERROR(hpack_decode_index(in, HPACK_M_INDEX, out, NULL));
    }

    /* 6.2.1. Literal Header Field with Incremental Indexing */
    else if ((c & HPACK_M_LITERAL_INDEX) == HPACK_F_LITERAL_INDEX) {
        /* 6 bit index */
        HANDLE_ERROR(hpack_decode_literal(in, HPACK_M_LITERAL_INDEX, out));
    }

    /* 6.2.2. Literal Header Field without Indexing */
    else if ((c & HPACK_M_LITERAL_NO_INDEX) == HPACK_F_LITERAL_NO_INDEX) {
        /* 4 bit index */
        HANDLE_ERROR(hpack_decode_literal(in, HPACK_M_LITERAL_NO_INDEX, out));
    }

    /* 6.2.3. Literal Header Field Never Indexed */
    else if ((c & HPACK_M_LITERAL_NO_INDEX) == HPACK_F_LITERAL_NO_INDEX) {
        /* 4 bit index */
        HANDLE_ERROR(hpack_decode_literal(in, HPACK_M_LITERAL_NO_INDEX, out));
    }

    /* 6.3. Dynamic Table Size Update */
    else if ((c & HPACK_M_TABLE_SIZE_UPDATE) == HPACK_F_TABLE_SIZE_UPDATE) {
        /* 5 bit index */
        int dummy;
        HANDLE_ERROR(hpack_decode_int(in, HPACK_M_TABLE_SIZE_UPDATE, &dummy));
    }

    /* unknown index */
    else {
        return HPACK_ERROR_DECODE_ERROR;
    }
}

int hpack_decode(byte *in_buf, size_t in_len, byte *out_buf, size_t out_len) {
    if (hpack_unlikely(!in_buf)) return HPACK_ERROR_DECODE_ERROR;
    if (hpack_unlikely(!out_buf)) return HPACK_ERROR_NO_MEMORY;

    hpack_stream_t read_buf = {
        .buf = in_buf,
        .off = 0,
        .max = in_len,
    };

    hpack_stream_t write_buf = {
        .buf = out_buf,
        .off = 0,
        .max = out_len,
    };

    do {
        HANDLE_ERROR(hpack_decode_incremental(&read_buf, &write_buf));
    } while (read_buf.off < read_buf.max);

    HANDLE_ERROR(hpack_write_char(&write_buf, 0));
    return HPACK_ERROR_NO_ERR;
}
/* decode fucntion end */

/* encode function start */
static int hpack_encode_int(int i, byte prefix, byte type, hpack_stream_t *out) {
    byte b, m;

    /* The first octet encodes up to prefix length bits */
    m = ~prefix;
    if (i <= m)
        b = (i & m) | type;
    else
        b = m | type;
    HANDLE_ERROR(hpack_write_char(out, b));
    i -= m;

    /* Encode the remainder as a varint */
    for (m = 0x80; i >= m; i /= m) {
        b = i % m + m;
        /* Set the continuation bit if there are steps left */
        if (i >= m) b |= m;
        HANDLE_ERROR(hpack_write_char(out, b));
    }

    if (i > 0) {
        HANDLE_ERROR(hpack_write_char(out, (byte)i));
    }
    return HPACK_ERROR_NO_ERR;
}

static int hpack_encode_str(hpack_stream_t *in, hpack_stream_t *out, byte split) {
    int len = 0;
    HANDLE_ERROR(hpack_strlen(in, split, &len));

    int encoded_len =hpack_huffman_calc_encode_len(in, len);

    if (encoded_len < len) {
        HANDLE_ERROR(hpack_encode_int(encoded_len, HPACK_M_LITERAL, HPACK_F_LITERAL_HUFFMAN, out));
        HANDLE_ERROR(hpack_huffman_encode_str(in, len, out));
    } else {
        HANDLE_ERROR(hpack_encode_int(len, HPACK_M_LITERAL, HPACK_F_LITERAL, out));
        HANDLE_ERROR(hpack_write_str(out, in->buf + in->off, len));
    }
    HANDLE_ERROR(hpack_drain(in, split));
    return HPACK_ERROR_NO_ERR;
}

int hpack_encode_index(hpack_stream_t *in, int *out_index, int *matched) {
    hpack_index_t *tbe;
    int first_index = 0;

    *matched = 0;
    for (int i = 0; i < HPACK_STATIC_SIZE; i++) {
        tbe = &static_table[i];
        if (hpack_has_str(in, tbe->name_len) < 0) {
            continue;
        }
        if (!strncmp(tbe->name, in->buf + in->off, tbe->name_len)) {
            if (hpack_likely(!tbe->value)) {
                if (SPLIT_1 == *(in->buf + in->off + tbe->name_len)) {
                    *out_index = tbe->id;
                    return HPACK_ERROR_NO_ERR;
                }
                continue;
            }

            if (!strncmp(tbe->value, in->buf + in->off + tbe->name_len + 1, strlen(tbe->value))) {
                if (SPLIT_2 == *(in->buf + in->off + tbe->name_len + 1 + strlen(tbe->value))) {
                    *out_index = tbe->id;
                    *matched = 1;
                    return HPACK_ERROR_NO_ERR;
                }
            }

            if (hpack_unlikely(!first_index)) first_index = tbe->id;
        }
    }
    *out_index = first_index;
    return HPACK_ERROR_NO_ERR;
}

int hpack_encode_incremental(hpack_stream_t *in, hpack_stream_t *out) {
    int i, use_value;
    HANDLE_ERROR((hpack_encode_index(in, &i, &use_value)));

    if (i) {
        if (use_value) {
            HANDLE_ERROR(hpack_encode_int(i, HPACK_M_INDEX, HPACK_F_INDEX, out));
            HANDLE_ERROR(hpack_drain(in, SPLIT_1));
            HANDLE_ERROR(hpack_drain(in, SPLIT_2));
            return HPACK_ERROR_NO_ERR;
        } else {
            HANDLE_ERROR(hpack_encode_int(i, HPACK_M_LITERAL_INDEX, HPACK_F_LITERAL_INDEX, out));
            HANDLE_ERROR(hpack_drain(in, SPLIT_1));
        }
    } else {
        HANDLE_ERROR(hpack_encode_int(0, HPACK_M_LITERAL_NO_INDEX, HPACK_F_LITERAL_NO_INDEX, out));
        HANDLE_ERROR(hpack_encode_str(in, out, SPLIT_1));
    }

    HANDLE_ERROR(hpack_encode_str(in, out, SPLIT_2));
}

int hpack_encode(byte *in_buf, size_t in_len, byte *out_buf, size_t out_len, size_t *encode_len) {
    if (hpack_unlikely(!in_buf)) return HPACK_ERROR_DECODE_ERROR;
    if (hpack_unlikely(!out_buf)) return HPACK_ERROR_NO_MEMORY;
    *encode_len = 0;

    hpack_stream_t read_buf = {
        .buf = in_buf,
        .off = 0,
        .max = in_len,
    };

    hpack_stream_t write_buf = {
        .buf = out_buf,
        .off = 0,
        .max = out_len,
    };

    do {
        HANDLE_ERROR(hpack_encode_incremental(&read_buf, &write_buf));
    } while (read_buf.off < read_buf.max);

    *encode_len = write_buf.off;
    return HPACK_ERROR_NO_ERR;
}
/* encode function end */

#undef SPLIT_1
#undef SPLIT_2
#undef HPACK_M_INDEX
#undef HPACK_F_INDEX
#undef HPACK_M_LITERAL_INDEX
#undef HPACK_F_LITERAL_INDEX
#undef HPACK_M_LITERAL_NO_INDEX
#undef HPACK_F_LITERAL_NO_INDEX
#undef HPACK_M_LITERAL_NEVER_INDEX
#undef HPACK_F_LITERAL_NEVER_INDEX
#undef HPACK_M_TABLE_SIZE_UPDATE
#undef HPACK_F_TABLE_SIZE_UPDATE
#undef HPACK_M_LITERAL
#undef HPACK_F_LITERAL
#undef HPACK_F_LITERAL_HUFFMAN
#undef hpack_likely
#undef hpack_unlikely
